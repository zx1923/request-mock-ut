[TOC]

模块化的思想有助于深刻理解业务，模块化考验的是对一个系统的构建能力，好的设计应该包含几点：

- 易于阅读；
- 易于维护；
- 易于扩展；

所以：

- 为什么一个 function 的定义不能超过 50 行；
- 为什么会有复杂度要求；
- 为什么不允许深层 if else 嵌套；

### 模块的实现

前端编程主要借助 JavaScript 进行，其模块化主要体现在：

- window 或 global 上的全局挂载；
- 文件之间的 export 导出和 import 导入；
- 单文件内 function 的定义和调用；

### 函数/方法

函数名和方法名应该与其具体的功能匹配，相配表示不能少做，也不能多做，而是恰到好处。

- 参数较少的情况下，例如少于 3 个时可以使用并列参数的方式定义参数；
- 参数较多的情况下，可以考虑使用 object 的方式传参，提高阅读性；
- 必须参数应该优先前排，非必须参数可以后排；
- 避免 `空字符串` 、`null` 和 `true/false` 等作为参数；
- 合理借助闭包特性，提高代码复用率；

### 逻辑优化

- 一个 if  能解决的问题就不要 if else ；
- 避免没有规律的 if else 嵌套，这会影响程序阅读；
- 可以尝试先判断不满足要求的情况，然后提前 return 掉；
- 不能觉得 forEach 就比 for 高级；

### 编码/提取/优化

提取和优化主要体现在对功能复用上，体现了模块化的思想。

- 参数校验可以抽离出方法，进行大量复用；
- 打点可以借助自定义指令，依托 Vue 框架更高效；
- 不必一味的追求单行代码；
- 注意 try catch 的使用场景，避免对大块代码 try catch ；
- if 判断能解决的可以不用 try catch ，if 判断不能解决的一定要 try catch ；
- 注意代码语义，程序开发中应尽可能体现语义信息，如对象展开等；

### Promise

应该深刻理解 Promise 的本质及其存在的意义，什么样的问题需要借助 Promise 来解决，以及如何解决。

在编程上，避免 Promise 内部嵌套 Promise 。

- Promise 的 then 应该怎么做；
- 应该怎样 catch 的异常；

```js
// getUserList 方法
```

### 递归

递归简单来说就是函数自己调用自己，很多场景都有递归的需求。

递归的前提是开发者可以提炼出功能的最小单元，递归实际上是对最小单元的重复调用；

```js
// 多级命令注册
// require引入
```

### 引申：模块引用

模块引用需要能理解引用的实质，到底是原型还是实例，如果是原型，则要考虑是否需要实例化后使用；如果是实例，则要考虑是否会存在异步并发调用的情况，防止引用污染。

### 引申：状态管理

为什么会有 Vuex ，它解决了哪些问题？

理解 vuex 的设计思想，才能更好的使用 vuex；反过来，只有深刻理解开发需求，才能开发出类似 Vuex 这样的工具。

需求和开发是相辅相成的。

### 引申：对象使用

- 空数组的判断，if (arr === []) 不能判断空数组；
- 空对象的判断，if (obj === {}) 不能判断孔对象；
- 对象的引用污染；

模块化的设计思想中，往往需要其内部数据也是模块化且独立的，所以 Vue 的 data 需要 return 一个对象；

在开发过程中，如果一个对象需要作为参数传递，则需要非常小心，避免无疑的改动导致对象被污染；

### 引申：组件间解耦

- $refs 是一种保底功能，不是万能途径，尽量避免使用 $refs 对子组件进行入侵式的调用；
- 不要在子组件中强行修改 props 的数据，如果需要修改，可以在父组件中使用 sync 修饰，并借助 update 事件来触发；
- 组件的功能应该独立，而非集合，组件存在的意义就是为了抽离出最小功能单元；
- 如果一个列表的 item 本身就是可复用的独立单元，那么子组件就应该是这个 item，而非整个 list ；
- 公共方法可以借助 import ，mixin ，filter 和 directive 来实现；