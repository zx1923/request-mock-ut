[TOC]

单元测试时对软件设计中的最小设计单元，可以是功能，可以是某个具体的函数，也可以是某个具体函数的某项具体的功能分支的验证。在普通的单元测试中，一般使用 Mock 技术来实现一些对外部依赖的模拟，以便能对指定单元进行针对性测试。

## 目前UT开发中的难点

- 不知道测什么，以及怎么测；
- 所测的方法或模块有依赖，依赖又有依赖，不知道该怎么处理；
- 尝试对依赖做一些Mock处理，但不知道处理到什么程度（Mock 不等于重写）；
- 不完全理解 Mock 的意义；

## 单元测试

为什么需要进行单元测试？

- 是对交付结果的检验；
- 是对代码逻辑的检验；
- 是对设计思想的检验；
- 反向驱动开发和设计；

### 交付结果

对交付结果而言，代码的实现可以是黑箱的，给定特定的输入，需要得到确定的输出，UT阶段可以检验这些输出，以便于判断某项功能单元是否符合设计目标。

### 代码逻辑

对代码逻辑而言，UT可以检测功能背后的实现过程；如：如何理解业务，如果设计逻辑分支等。

### 设计思想

设计思想体现在对业务的理解、抽象和拆解，体现在代码上则涉及到逻辑片段和设计模式等；好的设计思想指导下的UT应该也是很便于测试的。

### 驱动开发

设计合理的UT具备驱动开发设计的作用，根据设计思想不同，一般主流有两种分类：

- **TDD**: 测试驱动开发;
- **SDD**: 行为驱动开发；

反向驱动开发的一般流程：

- 基于需求和交付目标，编写测试用例；
- 测试这些用例；
- 用例没有通过，则修改或重构代码，直到全部用例通过为止。

然而真实的流程：

- 开发人员开发代码；
- 基于代码来定制用例；
- 用例测试全部通过。

建议的流程：

- 理解需求，拆分功能；
- 基于功能单元开发代码，编写用例；
- 代码开发完成，先进行用例测试；
- 如果用例不通过，则回笼代码，查漏补缺；

### 覆盖率

单元测试中的覆盖率是一个重要参考指标，也仅是个参考指标而已；覆盖率越高，说明对当前功能代码的测试约彻底，但并不代码功能的完备性就越好。

> 覆盖率很容易提高，但并不是覆盖率越高说明代码月健壮；一个健壮的单元是由开发、测试共同决定的，这两方面相辅相成，完备的开发和测试自然会产生较高的覆盖率。

## UT中的Mock

mock 是在测试过程中，对于一些不容易构造/获取的对象，创建一个 mock 对象来模拟对象的行为。

Mock 的主要意义在于确定单元测试中的主要矛盾和次要矛盾。

- 主要矛盾是对该项功能（单元）的测试验证；

- 次要矛盾是验证该项单元时可能需要的外部依赖；

将测试目标集中到要测试的功能单元上，非关键的模块或不便于引入的模块可以通过Mock手段来模拟。

>  UT 中的 mock 是对次要模块的快速实现，以便能对主要模块进行针对性测试。

## UT开发思路

无论是面向哪个端侧的单元测试，UT的首要思想是确定测试目标，这往往是某个特定的方法。

### 示例：Team list 测试

以 `Agcli` 工具的 `team list` 功能为例，AR要求用户在执行该命令时，可以在控制台罗列出接口返回的团队列表。

#### 明确目标

`team list` 命令执行过程中会调用 **edge** 模块发送 HTTP 请求，所以明确主要矛盾和次要矛盾：

- **主要矛盾**：`team list` 对用的入口函数 action 能否正确罗列团队信息，以为没有团队信息或用户未登录时的输出是否符合预期；
- **次要矛盾**：edge 模块能不能成功发送请求，用户是否已经登录；

自然而然的，测试目标也就明确了：

- **测试目标（ 等于交付结果）**：team list 命令能否要求输出信息到控制台。

#### 处理依赖

处理依赖的原则：

- 被测单元需要什么，就返回什么；

在这个测试示例中，edge 模块的属于依赖，`team list` 需要调用 edge 模块获取团队列表。

构建对 edge 模块的 Mock：

- 被测单元需要 edge 正确返回 teamList 且不为空，以便测试网络请求正常，且数据返回正常的情况；
- 被测单元需要 edge 正确返回，但 teamList 为空，以测试证当前没有创建团队的情况；
- 被测单元需要 edge 正确返回，但 ret.code 不为 0 ，以便测试对服务器错误的处理；
- 被测单元需要 edge 抛出异常，以测试证网络请求失败时的处理；

按照上述被测单元的需求，edge 可以被 Mock 四次，每次按照既定的要求范围，以便验证 `team list` 对不同情况下的处理能力。

#### 编写用例

编写用例需要尽可能考虑两个方面：

- 符合交付结果，即在以结果为导向的前提下，结果的覆盖率应该是 100%；
- 符合设计逻辑，大部分情况下交付结果不等于设计逻辑，所以要根据代码的实现逻辑来编写用例；

> 用例不通过时，在排除用例编写错误的前提先，应首先考虑被测单元是否有逻辑遗漏，而不是修改用例的断言让它变成通过。

#### 引申：通用型 Request Mock

针对当前的示例，一个快速Mock的方案是直接让 edge 模块返回一个 Promise 对象，携带被测单元所需的数据。

简单粗腰的方法虽然可以实现当前用例的测试，但也要考虑其他场景：

- 除了 `team list` 外的其他模块也需要调用 **edge** 模块发送请求；
- 其他被测模块所需的数据可能与 `team list` 不同；
- 并发测试时可能会出现 edge 覆盖问题；
- 重复的 Mock edge 会让代码很难维护；

所以，正确理解 UT 的含义后可以发现，edge 模块其实一个通用的 `http request` 模块，对任意一个请求进行 Mock ，可以总结为三部分的唯一映射：

- 请求地址；
- 请求方法；
- 数据响应；

所以，尝试设计一个专门处理 request 的 Mock 模块，以便后续可以轻松复用，这个模块应该要解决三个问题：

- 可以被实例化（避免并发测试时的单例覆盖问题）；
- 可以设置 **URL** => **Method** => **Response** 的映射关系，以便能快速响应；
- 可以轻松的对 response 进行修改，以便能测试不同返回值对应的逻辑处理是否正常。

期望的使用示例：

```js
// 正确响应
const resSuccess = {
  code: 0,
  msg: 'ok',
};

// 错误响应
const resError = {
  code: 403,
  msg: 'error',
};

// 定义模拟数据
const mockData = {
  userList: {
    url: '/app/user/list?code=123456',
    response: {
      data: [
        {
          name: 'Tom',
          age: 18
        },
        {
          name: 'Jack',
          age: 20
        }
      ]
    }
  }
}

const reqMock = new RequestMock();
// 期望得到 success
reqMock.mock(userList.url, userList.response, { ...resSuccess });
// 期望得到 error
reqMock.mock(userList.url, null, { ...resError });
```

## UT防坑指南

能准确理解单元测试的测试意图，才能写出好的测试用例，同时也能反向驱动，完善程序开发，避免没有意义测试用例。

### 坑1：没有意义的断言

```js
describe('test demo function', () => {
  const demo = jest.fn();

  test('demo', () => {
    const a = 1, b = 2;
    demo(1, 2);
    expect(demo).toBeCalledWith(a, b);
  });

});
```

上面的代码 `const demo = jest.fn();` 就是对 demo 的 Mock ，调用 demo 方法就意味着 demo 会被执行，再去判断 demo 被执行完全没有意义。

### 坑2：掩耳盗铃式的用例

命题：开发一个整数求和方法。

```js
function add(a, b) {
  return a + b;
}

// UT
test('add function', () => {
  const a = 1, b = 2;
  expect(add(a, b)).toBe(3);
});
```

上面的用例属于掩耳盗铃式的：**方法里写了啥，我就测啥**。

示例代码在跑测试时可以达到 100% 覆盖率，但这并不是好的方法，也不是好的测试。

上面的 add 函数是非常脆弱的，很容易因传参不当抛出异常，因为缺失很多场景判断，例如：

- 参数缺失的情况；
- 参数不定长的情况；
- 参数非整数的情况；
- 参数类型不是 Number 的情况；

## 引申：通用的 HTTP Mock 方法

前端开发中的 Mock 主要是针对 HTTP 请求的 Mock ，根据 Mock 形式不同，又分为拦截和打桩。

### 拦截

如果需要模拟一个完整的 HTTP 请求的，结合前端和后端，有三个常见的拦截和注入点：

- 应用层拦截，依赖常用的第三方 HTTP 请求模块，如 **axios** ；
- 环境底层拦截，如 web 端环境下，可以通过重写 **XMLHTTPRequest** 来实现请求拦截；
- 传输层拦截，由于 HTTP 本质上是基于 TCP 协议传输的，所以完全可以在 TCP 协议上拦截；

上述三个可拦截的点，还该了 web 端和 nodejs 端，实现成本递增向上，在 TCP 传输层拦截成本最高，除非是做特定的监听攻击，否在没有方案优势。

应用层的拦截成本最低。比如对 axios 进行拦截，由于 axios 本身就支持在 web 端和 nodejs 端使用，所以可以一劳永逸。

环境底层的拦截则适合一些针对性的场景，比如 `mockjs` 就是一个 web 端的 ajax mock 工具，其实现原理是重写了 **XMLHTTPRequest** 对象。

拦截 HTTP 请求后，web 端或者 node 端不会发送请求，也就不会和服务器建立连接，这种方式的返回值响应非常快，也相对好实现。

### 打桩

另一种方案是打桩，打桩是一种模拟端侧的方案，前端页面的请求正常发送，但是返回的数据是模拟出来的，并不是真实数据。

打桩的好处是前端不用在代码层修改实现，直接按照线上正常方式请求即可，这种方式更接近真实环境，所以测试结果也更加真实。

打桩需要部署打桩服务器，这既是优点也是缺点。

### All In One

可以尝试结合拦截和打桩的思路，实现一个兼容 web 端和 nodejs  端的接口 Mock 方案，实现思路为：

- 借鉴 UT 中 edge 的 mock 实现思路，本地通过 node 起一个 **mock server**；
- mock server 的数据可以通过借鉴 edge 的方案进行设置；
- 前端按照正常流程请求即可，必要情况下可以使用 fiddler 做一下代理；
- nodejs 端，或者 UT 侧保持不变，UT 可根据测试目标自由切换 edge 。